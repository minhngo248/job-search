#!/usr/bin/env ts-node
/**
 * Deployment script for configuring frontend environment variables.
 * 
 * This script extracts CDK stack outputs and creates environment configuration
 * files for the React frontend application.
 */

import * as AWS from 'aws-sdk';
import * as fs from 'fs';
import * as path from 'path';
import { CloudFormation, APIGateway } from 'aws-sdk';

interface StackOutput {
  [key: string]: string;
}

interface FrontendConfig {
  VITE_API_BASE_URL: string;
  VITE_API_KEY: string;
  VITE_API_GATEWAY_ID: string;
  VITE_API_STAGE: string;
}

interface RuntimeConfig {
  apiBaseUrl: string;
  apiKey: string;
  apiGatewayId: string;
  apiStage: string;
  deployedAt: string;
}

class FrontendConfigDeployer {
  private cloudformation: CloudFormation;
  private apigateway: APIGateway;
  private stackName: string;
  private region: string;

  constructor(stackName: string = 'RegulatoryJobsStack', region: string = 'eu-west-3') {
    this.stackName = stackName;
    this.region = region;
    
    AWS.config.update({ region });
    this.cloudformation = new AWS.CloudFormation();
    this.apigateway = new AWS.APIGateway();
  }

  /**
   * Retrieve outputs from the CDK stack.
   */
  async getStackOutputs(): Promise<StackOutput> {
    try {
      const response = await this.cloudformation.describeStacks({
        StackName: this.stackName,
      }).promise();

      const stacks = response.Stacks || [];
      
      if (stacks.length === 0) {
        throw new Error(`Stack '${this.stackName}' not found`);
      }

      const stack = stacks[0];
      const outputs = stack.Outputs || [];

      const outputDict: StackOutput = {};
      for (const output of outputs) {
        if (output.OutputKey && output.OutputValue) {
          outputDict[output.OutputKey] = output.OutputValue;
        }
      }

      return outputDict;
    } catch (error: any) {
      if (error.code === 'ValidationError') {
        throw new Error(`Stack '${this.stackName}' does not exist in region '${this.region}'`);
      } else {
        throw new Error(`Failed to retrieve stack outputs: ${error.message}`);
      }
    }
  }

  /**
   * Retrieve the actual API key value from API Gateway.
   */
  async getApiKeyValue(apiKeyId: string): Promise<string> {
    try {
      const response = await this.apigateway.getApiKey({
        apiKey: apiKeyId,
        includeValue: true,
      }).promise();

      return response.value || '';
    } catch (error: any) {
      throw new Error(`Failed to retrieve API key value: ${error.message}`);
    }
  }

  /**
   * Create environment file with configuration values.
   */
  createEnvFile(config: FrontendConfig, filePath: string): void {
    try {
      const dir = path.dirname(filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      const content = [
        '# Auto-generated environment configuration',
        '# Generated by deploy-frontend-config.ts',
        '',
        ...Object.entries(config).map(([key, value]) => `${key}=${value}`),
      ].join('\n');

      fs.writeFileSync(filePath, content);
      console.log(`‚úÖ Environment file created: ${filePath}`);
    } catch (error: any) {
      throw new Error(`Failed to create environment file: ${error.message}`);
    }
  }

  /**
   * Create JSON configuration file.
   */
  createJsonConfig(config: RuntimeConfig, filePath: string): void {
    try {
      const dir = path.dirname(filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(filePath, JSON.stringify(config, null, 2));
      console.log(`‚úÖ JSON config file created: ${filePath}`);
    } catch (error: any) {
      throw new Error(`Failed to create JSON config file: ${error.message}`);
    }
  }

  /**
   * Deploy frontend configuration by extracting CDK outputs and creating config files.
   */
  async deployFrontendConfig(frontendDir: string = '../frontend'): Promise<FrontendConfig> {
    console.log(`üöÄ Deploying frontend configuration from stack: ${this.stackName}`);

    try {
      // Get stack outputs
      console.log('üìã Retrieving CDK stack outputs...');
      const outputs = await this.getStackOutputs();

      const requiredOutputs = ['ApiGatewayUrl', 'ApiKeyId'];
      const missingOutputs = requiredOutputs.filter(key => !(key in outputs));

      if (missingOutputs.length > 0) {
        throw new Error(`Missing required stack outputs: ${missingOutputs.join(', ')}`);
      }

      // Get API key value
      console.log('üîë Retrieving API key value...');
      const apiKeyValue = await this.getApiKeyValue(outputs['ApiKeyId']);

      // Prepare configuration
      const config: FrontendConfig = {
        VITE_API_BASE_URL: outputs['ApiGatewayUrl'].replace(/\/$/, ''),
        VITE_API_KEY: apiKeyValue,
        VITE_API_GATEWAY_ID: outputs['ApiGatewayRestApiId'] || '',
        VITE_API_STAGE: outputs['ApiGatewayStage'] || 'prod',
      };

      // Create environment files
      const envLocalPath = path.join(frontendDir, '.env.local');
      const envProductionPath = path.join(frontendDir, '.env.production');
      const configJsonPath = path.join(frontendDir, 'src/config/deployment.json');

      console.log('üìù Creating configuration files...');

      // Create .env.local for development
      this.createEnvFile(config, envLocalPath);

      // Create .env.production for production builds
      this.createEnvFile(config, envProductionPath);

      // Create JSON config for runtime access
      const runtimeConfig: RuntimeConfig = {
        apiBaseUrl: config.VITE_API_BASE_URL,
        apiKey: config.VITE_API_KEY,
        apiGatewayId: config.VITE_API_GATEWAY_ID,
        apiStage: config.VITE_API_STAGE,
        deployedAt: new Date().toISOString(),
      };
      this.createJsonConfig(runtimeConfig, configJsonPath);

      console.log('‚úÖ Frontend configuration deployment completed successfully!');
      console.log('\nüìã Configuration Summary:');
      console.log(`   API Base URL: ${config.VITE_API_BASE_URL}`);
      console.log(`   API Key ID: ${outputs['ApiKeyId']}`);
      console.log(`   API Stage: ${config.VITE_API_STAGE}`);

      return config;
    } catch (error: any) {
      console.error(`‚ùå Frontend configuration deployment failed: ${error.message}`);
      throw error;
    }
  }
}

/**
 * Main entry point for the deployment script.
 */
async function main() {
  const args = process.argv.slice(2);
  
  // Parse command line arguments
  let stackName = 'RegulatoryJobsStack';
  let region = 'eu-west-3';
  let frontendDir = '../frontend';

  for (let i = 0; i < args.length; i += 2) {
    const flag = args[i];
    const value = args[i + 1];

    switch (flag) {
      case '--stack-name':
        stackName = value;
        break;
      case '--region':
        region = value;
        break;
      case '--frontend-dir':
        frontendDir = value;
        break;
      case '--help':
        console.log(`
Usage: ts-node deploy-frontend-config.ts [options]

Options:
  --stack-name <name>     Name of the CDK stack (default: RegulatoryJobsStack)
  --region <region>       AWS region (default: eu-west-3)
  --frontend-dir <path>   Path to frontend directory (default: ../frontend)
  --help                  Show this help message
        `);
        process.exit(0);
    }
  }

  try {
    // Check AWS credentials
    try {
      await new AWS.STS().getCallerIdentity().promise();
    } catch (error) {
      console.error('‚ùå AWS credentials not found. Please configure your AWS credentials.');
      console.error('   You can use: aws configure, AWS_PROFILE, or IAM roles');
      process.exit(1);
    }

    // Deploy configuration
    const deployer = new FrontendConfigDeployer(stackName, region);
    await deployer.deployFrontendConfig(frontendDir);

    console.log('\nüéâ Deployment completed! Frontend is ready to use the API.');
  } catch (error: any) {
    if (error.message.includes('KeyboardInterrupt')) {
      console.log('\n‚ö†Ô∏è  Deployment cancelled by user');
      process.exit(1);
    } else {
      console.error(`\n‚ùå Deployment failed: ${error.message}`);
      process.exit(1);
    }
  }
}

if (require.main === module) {
  main().catch(console.error);
}